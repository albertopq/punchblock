#!/usr/bin/env ruby
$:.push File.join(File.dirname(__FILE__), '..', 'lib')
require 'rubygems'
require 'bundler/setup'
require 'punchblock'
require 'pry'
require 'logger'
require 'optparse'

include Punchblock

Thread.abort_on_exception = true

options = { :username => 'usera@127.0.0.1', :password => '1', :wire_log_file => 'log/ozone-wire.log', :transport_log_file => 'log/ozone-transport.log', :ami => {:username => 'test', :password => 'password'} }

option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: punchblock-console [-u usera@127.0.0.1] [-p abc123]"
  opts.on("-u", "--username USERNAME", String, "Specify the XMPP JID to connect to") do |u|
    options[:username] = u
  end
  opts.on("-p", "--password PASSWORD", String, "Specify the XMPP password to use") do |p|
    options[:password] = p
  end
  opts.on("-d", "--ozone-domain DOMAIN", String, "Specify the domain Ozone is running on") do |d|
    options[:ozone_domain] = d
  end
  opts.on("-c", "--connection CONNECTION_TYPE", String, "Specify the connection type to use") do |c|
    options[:connection_type] = c.to_sym
  end
  opts.on("--wire-log-file log/wirelog.log", String, "Specify the file to which the wire log should be written") do |wlf|
    options[:wire_log_file] = wlf
  end
  opts.on("--transport-log-file log/transportlog.log", String, "Specify the file to which the transport log should be written") do |tlf|
    options[:transport_log_file] = tlf
  end
  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
  opts.on_tail("-v", "--version", "Show version") do
    puts VERSION
    exit
  end
end

begin
  option_parser.parse!
rescue
  puts $!
  option_parser.parse '--help'
end

options[:wire_logger] = Logger.new options.delete(:wire_log_file)
options[:wire_logger].level = Logger::DEBUG
options[:wire_logger].debug "Starting up..."
options[:transport_logger] = Logger.new options.delete(:transport_log_file)
options[:transport_logger].level = Logger::DEBUG
options[:transport_logger].debug "Starting up..."

protocol = Protocol.new options

protocol_thread = protocol.run

CALL_QUEUES = {}
INFO_EVENT_QUEUE = Queue.new

### DISPATCHER THREAD
# This thread multiplexes the event stream from the underlying connection handler and routes them
# to the correct queue for each call.  It also starts a call handler, the run_call method) after creating
# the queue.
Thread.new do
  loop do
    event = protocol.event_queue.pop
    if event == protocol.connected
      puts event
      puts "Waiting for a call..."
      next
    end
    puts "#{event.class} event for call: #{event.call_id}"
    case event
    when Protocol::Event::Offer
      raise "Duplicate call ID for #{event.call_id}" if CALL_QUEUES.has_key?(event.call_id)
      CALL_QUEUES[event.call_id] = Queue.new
      CALL_QUEUES[event.call_id].push event
      run_call protocol, event.call_id
    when Protocol::Event::Info
      INFO_EVENT_QUEUE.push event
    when Protocol::Event::Answered, Protocol::Event::Complete, Protocol::Event::End, Protocol::Event::Ringing
      CALL_QUEUES[event.call_id].push event
    else
      puts "Unknown event: #{event.inspect}"
    end

  end
end

def run_call(protocol, call_id)
  ### CALL THREAD
  # One thread is spun up to handle each call.
  Thread.new do
    raise StandardError, "Unknown call #{call_id}" unless CALL_QUEUES.has_key?(call_id)
    queue = CALL_QUEUES[call_id]
    offer = queue.pop
    dsl = DSL.new protocol, offer, queue

    puts "Incoming call to #{offer.headers_hash[:to]} from #{offer.headers_hash[:from]} #{offer}"
    dsl.pry

    # Clean up the queue.
    # CALL_QUEUES[call.call_id] = nil
  end
end

protocol_thread.join
